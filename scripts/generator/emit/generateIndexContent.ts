import path from 'path';

import type {
  Enum as TSDescriptorEnum,
  Message as TSDescriptorMessage,
  Service as TSDescriptorService,
} from '../descriptors';

import { wktFqnOf } from './helpers';
import { printEnum } from './printEnum';
import { printExtensions } from './printExtensions';
import { printMessage } from './printMessage/index';
import { printService, type TypeIndex } from './printService';

export function generateIndexContent(
  dir: string,
  entries: {
    pbFile: string;
    pkg: string;
    enums: TSDescriptorEnum[];
    messages?: TSDescriptorMessage[];
    services?: TSDescriptorService[];
    extensions?: import('../descriptors').Field[];
  }[],
  typeIndex: TypeIndex,
  // Number of path segments under src where plugin outputs files, e.g. "generated_test/2" => 2
  outFromSrcDepth: number,
  // OPTIONAL: absolute (repo-root relative) output base path passed via plugin param `outBase`.
  // If provided, it represents the directory used as `out` in buf.gen.yaml (e.g. "scripts/generator/tmp_out").
  // When set we IGNORE outFromSrcDepth logic and compute relative imports from that base to src/..
  outBase?: string,
  // Relative path (inside the plugin output root) to the generated registry file (default: protobuf.ts)
  registryFile?: string,
  // Global map extendeeFqn(normalized) -> extensions
  _extensionMap?: Map<string, import('../descriptors').Field[]>,
): string {
  const lines: string[] = [];
  lines.push('/* Generated by Nebius TS generator. DO NOT EDIT! */');
  lines.push('');
  let runtimeImport: string;
  let up: string; // path from generated file (dir) to src (used for other runtime imports)
  // Compute relative import to registry file
  const registryRelPath = (() => {
    const reg = registryFile || 'protobuf.ts';
    const regDir = path.posix.dirname(reg);
    const fromDir = dir || '.';
    let rel = path.posix.relative(fromDir, regDir === '.' ? '.' : regDir);
    if (!rel || rel === '.') rel = '.'; // same directory
    const baseNoExt = path.posix.basename(reg).replace(/\.ts$/, '');
    const full = rel === '.' ? `./${baseNoExt}` : `${rel}/${baseNoExt}`;
    return full.startsWith('.') ? full : `./${full}`;
  })();

  if (outBase) {
    // Generic path math: relative path from <outBase>/<dir> to src/runtime/protos/index
    const from = path.posix.join(outBase || '.', dir || '.');
    // Always posix relative (buf provides posix style paths)
    runtimeImport = path.posix.relative(from, 'src/runtime/protos/index');
    if (!runtimeImport.startsWith('.')) runtimeImport = `./${runtimeImport}`;
    up = path.posix.relative(from, 'src');
    if (!up.startsWith('.')) up = `./${up}`; // may be just ./src if from is repo root
  } else {
    // Legacy behavior: output lives under src/, only know depth inside src.
    // Compute relative import to src/runtime/protos from src/<outFromSrc>/<dir>/index.ts
    const dirDepth = dir && dir !== '.' ? dir.split('/').filter(Boolean).length : 0;
    const depth = dirDepth + (outFromSrcDepth || 0);
    up = Array.from({ length: depth }, () => '..').join('/');
    runtimeImport = `${up}/runtime/protos/index`;
  }

  // Always import common runtime helpers. Some may be unused in a given file; consumers can tree-shake.
  lines.push(
    `import { BinaryReader, BinaryWriter, DeepPartial, isSet, Long, bytesFromBase64, base64FromBytes, wkt, createEnum, unknownFieldsSymbol } from "${runtimeImport}"`,
  );
  // Local (generated) registry import
  lines.push(`import { protoRegistry } from "${registryRelPath}";`);
  // Import runtime types used in generated declarations. EnumClass is required for the per-enum
  // intersection type (<EnumName>Class) that augments value members with hover JSDoc.
  lines.push(
    `import type { Dayjs, Duration, MessageFns, EnumInstance, EnumClass } from "${runtimeImport}";`,
  );

  // If there are any services in this directory, import grpc-js types used by printed services
  const hasServices = entries.some((e) => (e.services?.length ?? 0) > 0);

  // Track if any service method returns Operation to import Operation wrapper and OperationServiceBaseClient
  const OP_V1 = '.nebius.common.v1.Operation';
  const OP_V1A = '.nebius.common.v1alpha1.Operation';
  let needsOperationWrapper = false;
  let needsOpServiceV1 = false;
  let needsOpServiceV1A = false;

  // Build external imports for referenced symbols in other directories
  const importMap = new Map<string, Set<string>>(); // targetDir -> symbols
  const addImport = (targetDir: string, name: string) => {
    if (!importMap.has(targetDir)) importMap.set(targetDir, new Set());
    importMap.get(targetDir)!.add(name);
  };

  for (const { messages } of entries) {
    if (!messages) continue;
    for (const m of messages) {
      for (const f of m.fields) {
        // Handle map value types specially
        if (f.isMap()) {
          const entry = f.message();
          const vf = entry?.fields.find((x) => x.descriptor.number === 2);
          if (!vf) continue;
          const wkt = wktFqnOf(vf);
          if (vf.isMessage()) {
            if (!wkt) {
              const ref = vf.message();
              const fileName = ref?.containingFile.descriptor.name;
              if (fileName) {
                const targetDir = path.posix.dirname(fileName);
                if (targetDir !== (dir || '.')) addImport(targetDir, ref!.tsName);
              }
            }
          } else if (vf.isEnum()) {
            const ref = vf.enum();
            const fileName = ref?.containingFile.descriptor.name;
            if (fileName) {
              const targetDir = path.posix.dirname(fileName);
              if (targetDir !== (dir || '.')) {
                addImport(targetDir, ref!.tsName);
              }
            }
          }
          continue;
        }

        if (f.isMessage()) {
          const wkt = wktFqnOf(f);
          if (wkt) continue; // WKTs handled by runtime
          const ref = f.message();
          const fileName = ref?.containingFile.descriptor.name;
          if (!fileName) continue;
          const targetDir = path.posix.dirname(fileName);
          if (targetDir !== (dir || '.')) addImport(targetDir, ref!.tsName);
        } else if (f.isEnum()) {
          const ref = f.enum();
          const fileName = ref?.containingFile.descriptor.name;
          if (!fileName) continue;
          const targetDir = path.posix.dirname(fileName);
          if (targetDir !== (dir || '.')) {
            addImport(targetDir, ref!.tsName);
          }
        }
      }
    }
  }

  // Also add imports needed by service request/response types and detect Operation returns
  for (const { services, pkg } of entries) {
    if (!services?.length) continue;
    for (const s of services) {
      for (const m of s.methods) {
        const inType = m.descriptor.inputType || '';
        const outType = m.descriptor.outputType || '';
        // Find type info in typeIndex
        const inKey = inType.startsWith('.') ? inType : `.${pkg}${inType ? '.' + inType : ''}`;
        const outKey = outType.startsWith('.') ? outType : `.${pkg}${outType ? '.' + outType : ''}`;
        const inInfo = typeIndex.get(inKey);
        const outInfo = typeIndex.get(outKey);
        if (inInfo && inInfo.dir !== (dir || '.')) addImport(inInfo.dir, inInfo.tsName);
        if (outInfo && outInfo.dir !== (dir || '.')) addImport(outInfo.dir, outInfo.tsName);
        if (outKey === OP_V1) {
          needsOperationWrapper = true;
          needsOpServiceV1 = true;
        }
        if (outKey === OP_V1A) {
          needsOperationWrapper = true;
          needsOpServiceV1A = true;
        }
      }
    }
  }

  if (hasServices) {
    lines.push(
      `import { ChannelCredentials, Client, ClientUnaryCall, ClientOptions, CallOptions, Metadata, ServiceError as GrpcServiceError, handleUnaryCall, makeGenericClientConstructor, UntypedServiceImplementation } from "@grpc/grpc-js";`,
    );
    // Imports for SDK wrapper
    lines.push(`import type { SDKInterface } from "${up}/sdk";`);
    lines.push(
      `import { wrapUnaryCall, type UnaryCall, type RetryOptions } from "${up}/runtime/request";`,
    );
    if (needsOperationWrapper) {
      lines.push(`import { Operation as OperationWrapper } from "${up}/runtime/operation";`);
    }
  }

  // If we need Operation service base client, import it from common directories
  if (needsOpServiceV1) {
    // Import from nebius/common/v1 index
    addImport('nebius/common/v1', 'OperationServiceBaseClient');
  }
  if (needsOpServiceV1A) {
    addImport('nebius/common/v1alpha1', 'OperationServiceBaseClient');
  }

  // Emit imports (sorted) after runtime/grpc imports
  if (importMap.size) {
    const sortedDirs = [...importMap.keys()].sort();
    for (const tDir of sortedDirs) {
      const names = [...(importMap.get(tDir) ?? new Set())].sort();
      let rel = path.posix.relative(dir || '.', tDir || '.');
      if (!rel || rel === '.') continue; // same dir, no import
      if (!rel.startsWith('.')) rel = `./${rel}`;
      lines.push(`import { ${names.join(', ')} } from "${rel}";`);
    }
  }
  // Track augmentation module targets to avoid duplicate empty imports
  const augmentationImported = new Set<string>();
  lines.push('');

  for (const { pbFile, pkg, enums, messages, services, extensions } of entries) {
    lines.push(`// file: ${pbFile}`);
    for (const e of enums) lines.push(printEnum(e));
    if (messages && messages.length) {
      for (const m of messages) {
        lines.push(printMessage(m));
      }
    }
    if (services && services.length) {
      // pbFile is just the basename; reconstruct relative proto path for source fallback
      const protoRelPath = dir && dir !== '.' ? `${dir}/${pbFile}` : pbFile;
      for (const s of services) {
        lines.push(printService(s, pkg, typeIndex, protoRelPath));
      }
    }
    // Emit extensions via dedicated printer
    lines.push(...printExtensions(extensions, pkg, dir || '.', augmentationImported));
    lines.push('');
  }
  return lines.join('\n');
}
