import path from 'path';

import type {
  Enum as TSDescriptorEnum,
  Message as TSDescriptorMessage,
  Service as TSDescriptorService,
} from '../descriptors';

import { wktFqnOf } from './helpers';
import { printEnum } from './printEnum';
import { printExtensions } from './printExtensions';
import { printMessage } from './printMessage/index';
import { printService, type TypeIndex } from './printService';
import { withTypeNameContext } from './typeNames';

export function generateIndexContent(
  dir: string,
  entries: {
    pbFile: string;
    pkg: string;
    enums: TSDescriptorEnum[];
    messages?: TSDescriptorMessage[];
    services?: TSDescriptorService[];
    extensions?: import('../descriptors').Field[];
  }[],
  typeIndex: TypeIndex,
  // Number of path segments under src where plugin outputs files, e.g. "generated_test/2" => 2
  outFromSrcDepth: number,
  // OPTIONAL: absolute (repo-root relative) output base path passed via plugin param `outBase`.
  // If provided, it represents the directory used as `out` in buf.gen.yaml (e.g. "scripts/generator/tmp_out").
  // When set we IGNORE outFromSrcDepth logic and compute relative imports from that base to src/..
  outBase?: string,
  // Relative path (inside the plugin output root) to the generated registry file (default: protobuf.ts)
  registryFile?: string,
  // Global map extendeeFqn(normalized) -> extensions
  _extensionMap?: Map<string, import('../descriptors').Field[]>,
): string {
  const lines: string[] = [];
  lines.push('/* Generated by Nebius TS generator. DO NOT EDIT! */');
  lines.push('');
  let runtimeImport: string;
  let up: string; // path from generated file (dir) to src (used for other runtime imports)
  // Compute relative import to registry file
  const registryRelPath = (() => {
    const reg = registryFile || 'protobuf.ts';
    const regDir = path.posix.dirname(reg);
    const fromDir = dir || '.';
    let rel = path.posix.relative(fromDir, regDir === '.' ? '.' : regDir);
    if (!rel || rel === '.') rel = '.'; // same directory
    const baseNoExt = path.posix.basename(reg).replace(/\.ts$/, '');
    const full = rel === '.' ? `./${baseNoExt}` : `${rel}/${baseNoExt}`;
    return full.startsWith('.') ? full : `./${full}`;
  })();

  if (outBase) {
    // Generic path math: relative path from <outBase>/<dir> to src/runtime/protos/index
    const from = path.posix.join(outBase || '.', dir || '.');
    // Always posix relative (buf provides posix style paths)
    runtimeImport = path.posix.relative(from, 'src/runtime/protos/index');
    if (!runtimeImport.startsWith('.')) runtimeImport = `./${runtimeImport}`;
    up = path.posix.relative(from, 'src');
    if (!up.startsWith('.')) up = `./${up}`; // may be just ./src if from is repo root
  } else {
    // Legacy behavior: output lives under src/, only know depth inside src.
    // Compute relative import to src/runtime/protos from src/<outFromSrc>/<dir>/index.ts
    const dirDepth = dir && dir !== '.' ? dir.split('/').filter(Boolean).length : 0;
    const depth = dirDepth + (outFromSrcDepth || 0);
    up = Array.from({ length: depth }, () => '..').join('/');
    runtimeImport = `${up}/runtime/protos/index`;
  }

  // Always import common runtime helpers. Some may be unused in a given file; consumers can tree-shake.
  lines.push(
    `import { BinaryReader, BinaryWriter, DeepPartial, isSet, Long, bytesFromBase64, base64FromBytes, wkt, createEnum, unknownFieldsSymbol } from "${runtimeImport}"`,
  );
  // util.inspect for human-friendly string formatting
  lines.push(`import { inspect } from "util";`);
  // Local (generated) registry import
  lines.push(`import { protoRegistry } from "${registryRelPath}";`);
  // Import runtime types used in generated declarations. EnumClass is required for the per-enum
  // intersection type (<EnumName>Class) that augments value members with hover JSDoc.
  lines.push(
    `import type { Dayjs, Duration, MessageFns, EnumInstance, EnumClass } from "${runtimeImport}";`,
  );
  lines.push(
    `import { deprecatedWarn, custom, customJson, inspectJson } from "${up}/runtime/util/logging";`,
  );
  // Token sanitizer for credential fields
  lines.push(`import { TokenSanitizer } from "${up}/runtime/token_sanitizer";`);

  // If there are any services in this directory, import grpc-js types used by printed services
  const hasServices = entries.some((e) => (e.services?.length ?? 0) > 0);

  // Track if any service method returns Operation to import Operation wrapper and OperationServiceBaseClient
  const OP_V1 = '.nebius.common.v1.Operation';
  const OP_V1A = '.nebius.common.v1alpha1.Operation';
  let needsOperationWrapper = false;
  let needsOpServiceV1 = false;
  let needsOpServiceV1A = false;

  const localNames = new Set<string>();
  for (const { enums, messages, services } of entries) {
    for (const e of enums) localNames.add(e.tsNameOriginal ?? e.tsName);
    for (const m of messages ?? []) localNames.add(m.tsNameOriginal ?? m.tsName);
    for (const s of services ?? []) localNames.add(s.tsNameOriginal ?? s.tsName);
  }
  const usedNames = new Set<string>(localNames);
  const typeNameOverrides = new Map<string, string>();
  const symbolNameOverrides = new Map<string, string>();
  type ImportSpec = { original: string; name: string };
  // Build external imports for referenced symbols in other directories
  const importMap = new Map<string, Map<string, ImportSpec>>(); // targetDir -> original -> spec
  const importSpecs = new Map<string, ImportSpec>();
  const localDir = dir || '.';
  const toPascal = (value: string): string => {
    const parts = value.split(/[^a-zA-Z0-9]+/).filter(Boolean);
    if (!parts.length) return '';
    const out = parts.map((part) => (part ? part[0].toUpperCase() + part.slice(1) : '')).join('');
    if (!out) return '';
    return /^\d/.test(out) ? `V${out}` : out;
  };
  const importPrefix = (targetDir: string): string => {
    const targetParts = targetDir === '.' ? [] : targetDir.split('/').filter(Boolean);
    const localParts = localDir === '.' ? [] : localDir.split('/').filter(Boolean);
    let idx = 0;
    while (idx < targetParts.length && idx < localParts.length) {
      if (targetParts[idx] !== localParts[idx]) break;
      idx += 1;
    }
    let parts = targetParts.slice(idx);
    if (!parts.length) parts = targetParts.slice(-2);
    const prefix = parts.map(toPascal).join('');
    return prefix || 'Imported';
  };
  const uniqueName = (base: string): string => {
    let name = base;
    let i = 2;
    while (usedNames.has(name)) {
      name = `${base}${i}`;
      i += 1;
    }
    return name;
  };
  const addImport = (targetDir: string, originalName: string, fqn?: string): string => {
    const key = `${targetDir}::${originalName}`;
    let spec = importSpecs.get(key);
    if (!spec) {
      let name = originalName;
      if (usedNames.has(name)) {
        const base = `${importPrefix(targetDir)}${originalName}`;
        name = uniqueName(base);
      }
      spec = { original: originalName, name };
      importSpecs.set(key, spec);
      if (!importMap.has(targetDir)) importMap.set(targetDir, new Map());
      importMap.get(targetDir)!.set(originalName, spec);
      usedNames.add(name);
      symbolNameOverrides.set(key, name);
    }
    if (fqn) typeNameOverrides.set(fqn, spec.name);
    return spec.name;
  };

  for (const { messages } of entries) {
    if (!messages) continue;
    for (const m of messages) {
      for (const f of m.fields) {
        // Handle map value types specially
        if (f.isMap()) {
          const entry = f.message();
          const vf = entry?.fields.find((x) => x.descriptor.number === 2);
          if (!vf) continue;
          const wkt = wktFqnOf(vf);
          if (vf.isMessage()) {
            if (!wkt) {
              const ref = vf.message();
              const fileName = ref?.containingFile.descriptor.name;
              if (fileName) {
                const targetDir = path.posix.dirname(fileName);
                if (targetDir !== (dir || '.')) {
                  addImport(
                    targetDir,
                    ref!.tsNameOriginal ?? ref!.tsName,
                    ref!.fullQualifiedName(),
                  );
                }
              }
            }
          } else if (vf.isEnum()) {
            const ref = vf.enum();
            const fileName = ref?.containingFile.descriptor.name;
            if (fileName) {
              const targetDir = path.posix.dirname(fileName);
              if (targetDir !== (dir || '.')) {
                addImport(targetDir, ref!.tsNameOriginal ?? ref!.tsName, ref!.fullQualifiedName());
              }
            }
          }
          continue;
        }

        if (f.isMessage()) {
          const wkt = wktFqnOf(f);
          if (wkt) continue; // WKTs handled by runtime
          const ref = f.message();
          const fileName = ref?.containingFile.descriptor.name;
          if (!fileName) continue;
          const targetDir = path.posix.dirname(fileName);
          if (targetDir !== (dir || '.')) {
            addImport(targetDir, ref!.tsNameOriginal ?? ref!.tsName, ref!.fullQualifiedName());
          }
        } else if (f.isEnum()) {
          const ref = f.enum();
          const fileName = ref?.containingFile.descriptor.name;
          if (!fileName) continue;
          const targetDir = path.posix.dirname(fileName);
          if (targetDir !== (dir || '.')) {
            addImport(targetDir, ref!.tsNameOriginal ?? ref!.tsName, ref!.fullQualifiedName());
          }
        }
      }
    }
  }

  // Also add imports needed by service request/response types and detect Operation returns
  for (const { services, pkg } of entries) {
    if (!services?.length) continue;
    for (const s of services) {
      for (const m of s.methods) {
        const inType = m.descriptor.inputType || '';
        const outType = m.descriptor.outputType || '';
        // Find type info in typeIndex
        const inKey = inType.startsWith('.') ? inType : `.${pkg}${inType ? '.' + inType : ''}`;
        const outKey = outType.startsWith('.') ? outType : `.${pkg}${outType ? '.' + outType : ''}`;
        const inInfo = typeIndex.get(inKey);
        const outInfo = typeIndex.get(outKey);
        if (inInfo && inInfo.dir !== (dir || '.')) {
          addImport(inInfo.dir, inInfo.tsNameOriginal ?? inInfo.tsName, inKey);
        }
        if (outInfo && outInfo.dir !== (dir || '.')) {
          addImport(outInfo.dir, outInfo.tsNameOriginal ?? outInfo.tsName, outKey);
        }
        if (outKey === OP_V1) {
          needsOperationWrapper = true;
          needsOpServiceV1 = true;
        }
        if (outKey === OP_V1A) {
          needsOperationWrapper = true;
          needsOpServiceV1A = true;
        }
      }
    }
  }

  if (hasServices) {
    lines.push(
      `import { ChannelCredentials, Client, ClientUnaryCall, ClientOptions, CallOptions, Metadata, ServiceError as GrpcServiceError, handleUnaryCall, makeGenericClientConstructor, UntypedServiceImplementation } from "@grpc/grpc-js";`,
    );
    // Imports for SDK wrapper
    lines.push(`import type { SDKInterface } from "${up}/sdk";`);
    lines.push(
      `import { Request as SDKRequestClass, type RetryOptions } from "${up}/runtime/request";`,
    );
    if (needsOperationWrapper) {
      lines.push(`import { Operation as OperationWrapper } from "${up}/runtime/operation";`);
    }
  }

  // If we need Operation service base client, import it from common directories
  if (needsOpServiceV1) {
    // Import from nebius/common/v1 index
    if (localDir !== 'nebius/common/v1') {
      addImport('nebius/common/v1', 'OperationServiceServiceDescription');
      addImport('nebius/common/v1', 'OperationService');
      addImport('nebius/common/v1', 'GetOperationRequest', '.nebius.common.v1.GetOperationRequest');
    }
  }
  if (needsOpServiceV1A) {
    if (localDir !== 'nebius/common/v1alpha1') {
      addImport('nebius/common/v1alpha1', 'OperationServiceServiceDescription');
      addImport('nebius/common/v1alpha1', 'OperationService');
      addImport(
        'nebius/common/v1alpha1',
        'GetOperationRequest',
        '.nebius.common.v1alpha1.GetOperationRequest',
      );
    }
  }

  // Emit imports (sorted) after runtime/grpc imports
  if (importMap.size) {
    const sortedDirs = [...importMap.keys()].sort();
    for (const tDir of sortedDirs) {
      const specs = [...(importMap.get(tDir)?.values() ?? [])].sort((a, b) => {
        const byName = a.name.localeCompare(b.name);
        return byName !== 0 ? byName : a.original.localeCompare(b.original);
      });
      const names = specs.map((spec) =>
        spec.name === spec.original ? spec.original : `${spec.original} as ${spec.name}`,
      );
      let rel = path.posix.relative(dir || '.', tDir || '.');
      if (!rel || rel === '.') continue; // same dir, no import
      if (!rel.startsWith('.')) rel = `./${rel}`;
      lines.push(`import { ${names.join(', ')} } from "${rel}";`);
    }
  }
  // Track augmentation module targets to avoid duplicate empty imports
  const augmentationImported = new Set<string>();
  // File-local set used by generated code to avoid spamming repeated warnings at runtime.
  // This variable is emitted once per generated index file and shared by all types in that file.
  lines.push('');
  lines.push('const __deprecatedWarned = new Set<string>();');
  lines.push('');

  return withTypeNameContext(typeNameOverrides, symbolNameOverrides, () => {
    for (const { pbFile, pkg, enums, messages, services, extensions } of entries) {
      lines.push(`// file: ${pbFile}`);
      for (const e of enums) lines.push(printEnum(e));
      if (messages && messages.length) {
        for (const m of messages) {
          lines.push(printMessage(m));
        }
      }
      if (services && services.length) {
        // pbFile is just the basename; reconstruct relative proto path for source fallback
        const protoRelPath = dir && dir !== '.' ? `${dir}/${pbFile}` : pbFile;
        for (const s of services) {
          lines.push(printService(s, pkg, typeIndex, protoRelPath));
        }
      }
      // Emit extensions via dedicated printer
      lines.push(...printExtensions(extensions, pkg, dir || '.', augmentationImported));
      lines.push('');
    }
    return lines.join('\n');
  });
}
