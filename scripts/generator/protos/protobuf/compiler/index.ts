/* Generated by Nebius TS generator. DO NOT EDIT! */

import { BinaryReader, BinaryWriter, DeepPartial, isSet, Long, bytesFromBase64, base64FromBytes, wkt, createEnum, unknownFieldsSymbol } from "../../../../../src/runtime/protos/index"
import { inspect } from "util";
import { protoRegistry } from "../../registry";
import type { Dayjs, Duration, MessageFns, EnumInstance, EnumClass } from "../../../../../src/runtime/protos/index";
import { deprecatedWarn, custom, customJson, inspectJson } from "../../../../../src/runtime/util/logging";
import { TokenSanitizer } from "../../../../../src/runtime/token_sanitizer";
import { FileDescriptorProto, GeneratedCodeInfo } from "..";

const __deprecatedWarned = new Set<string>();

// file: plugin.proto
/**
 *  Sync with code_generator.h.
 *
 */
export type CodeGeneratorResponse_Feature = EnumInstance<"UNRECOGNIZED" | "FEATURE_NONE" | "FEATURE_PROTO3_OPTIONAL" | "FEATURE_SUPPORTS_EDITIONS">;

interface CodeGeneratorResponse_FeatureValueMembers {
  readonly FEATURE_NONE: EnumInstance<"UNRECOGNIZED" | "FEATURE_NONE" | "FEATURE_PROTO3_OPTIONAL" | "FEATURE_SUPPORTS_EDITIONS">;
  readonly FEATURE_PROTO3_OPTIONAL: EnumInstance<"UNRECOGNIZED" | "FEATURE_NONE" | "FEATURE_PROTO3_OPTIONAL" | "FEATURE_SUPPORTS_EDITIONS">;
  readonly FEATURE_SUPPORTS_EDITIONS: EnumInstance<"UNRECOGNIZED" | "FEATURE_NONE" | "FEATURE_PROTO3_OPTIONAL" | "FEATURE_SUPPORTS_EDITIONS">;
}
export type CodeGeneratorResponse_FeatureClass = EnumClass<"UNRECOGNIZED" | "FEATURE_NONE" | "FEATURE_PROTO3_OPTIONAL" | "FEATURE_SUPPORTS_EDITIONS"> & CodeGeneratorResponse_FeatureValueMembers;

export const CodeGeneratorResponse_Feature = createEnum("google.protobuf.compiler.CodeGeneratorResponse.Feature", {
  FEATURE_NONE: 0,
  FEATURE_PROTO3_OPTIONAL: 1,
  FEATURE_SUPPORTS_EDITIONS: 2,
}) as CodeGeneratorResponse_FeatureClass;

protoRegistry.registerEnum(CodeGeneratorResponse_Feature);

/**
 *  The version number of protocol compiler.
 *
 */
export interface Version {
  $type: "google.protobuf.compiler.Version";
  [unknownFieldsSymbol]?: Uint8Array | undefined;
  [custom]?: () => string;
  [customJson]?: () => unknown;
  major?: number | undefined;
  minor?: number | undefined;
  patch?: number | undefined;
  /**
   *  A suffix for alpha, beta or rc release, e.g., "alpha-1", "rc2". It should
   *  be empty for mainline stable releases.
   *
   */
  suffix?: string | undefined;
}

export const Version: MessageFns<Version, "google.protobuf.compiler.Version"> = {
  $type: "google.protobuf.compiler.Version" as const,

  encode(message: Version, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.major !== undefined) {
      writer.uint32(8).int32(message.major);
    }
    if (message.minor !== undefined) {
      writer.uint32(16).int32(message.minor);
    }
    if (message.patch !== undefined) {
      writer.uint32(24).int32(message.patch);
    }
    if (message.suffix !== undefined) {
      writer.uint32(34).string(message.suffix);
    }
    if (message[unknownFieldsSymbol]) {
      writer.raw(message[unknownFieldsSymbol]);
    }
    return writer;
  },
  decode(input: BinaryReader | Uint8Array, length?: number): Version {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVersion();
    let writer: BinaryWriter | undefined = undefined;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
        if (tag !== 8) break;
        message.major = reader.int32();
        continue;
      }
        case 2: {
        if (tag !== 16) break;
        message.minor = reader.int32();
        continue;
      }
        case 3: {
        if (tag !== 24) break;
        message.patch = reader.int32();
        continue;
      }
        case 4: {
        if (tag !== 34) break;
        message.suffix = reader.string();
        continue;
      }
        default:
          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      {
        if (!writer) writer = new BinaryWriter();
        const skipped = reader.skip(tag & 7, tag >>> 3);
        writer.uint32(tag).raw(skipped);
      }
    }
    if (writer) {
      message[unknownFieldsSymbol] = writer.finish();
    }
    return message;
  },
  fromJSON(object: any): Version {
    return applyVersionCustom({
      $type: "google.protobuf.compiler.Version",
      major: isSet(object.major ?? object.major)
        ? Number(object.major ?? object.major)
        : undefined,
      minor: isSet(object.minor ?? object.minor)
        ? Number(object.minor ?? object.minor)
        : undefined,
      patch: isSet(object.patch ?? object.patch)
        ? Number(object.patch ?? object.patch)
        : undefined,
      suffix: isSet(object.suffix ?? object.suffix)
        ? String(object.suffix ?? object.suffix)
        : undefined,
    });
  },
  toJSON(message: Version, use: "json" | "pb" = "json"): unknown {
    const obj: any = {};
    const pick = (json: string, pb: string) => (use === "json" ? json : pb);
    if (message.major !== undefined) {
      obj[pick("major", "major")] = message.major;
    }
    if (message.minor !== undefined) {
      obj[pick("minor", "minor")] = message.minor;
    }
    if (message.patch !== undefined) {
      obj[pick("patch", "patch")] = message.patch;
    }
    if (message.suffix !== undefined) {
      obj[pick("suffix", "suffix")] = message.suffix;
    }
    return obj;
  },
  create<I extends DeepPartial<Version>>(base?: I): Version {
    return Version.fromPartial(base ?? {});
  },
  fromPartial<I extends DeepPartial<Version>>(object: I): Version {
    const message = createBaseVersion();
    message.major = (object.major !== undefined && object.major !== null)
      ? object.major
      : undefined;
    message.minor = (object.minor !== undefined && object.minor !== null)
      ? object.minor
      : undefined;
    message.patch = (object.patch !== undefined && object.patch !== null)
      ? object.patch
      : undefined;
    message.suffix = (object.suffix !== undefined && object.suffix !== null)
      ? object.suffix
      : undefined;
    return message;
  },
};

protoRegistry.registerMessage(Version);

function VersionCustomInspect(this: Version): string {
  const parts: string[] = [];
  if (this.major !== undefined) parts.push("major" + "=" + inspect(this.major));
  if (this.minor !== undefined) parts.push("minor" + "=" + inspect(this.minor));
  if (this.patch !== undefined) parts.push("patch" + "=" + inspect(this.patch));
  if (this.suffix !== undefined) parts.push("suffix" + "=" + inspect(this.suffix));
  return `${this.$type}(${parts.join(", ")})`;
}

function VersionCustomJson(this: Version): unknown {
  const obj: globalThis.Record<string, unknown> = {
    type: this.$type,
  };
  if (this.major !== undefined) obj.major = inspectJson(this.major);
  if (this.minor !== undefined) obj.minor = inspectJson(this.minor);
  if (this.patch !== undefined) obj.patch = inspectJson(this.patch);
  if (this.suffix !== undefined) obj.suffix = inspectJson(this.suffix);
  return obj;
}

function applyVersionCustom(message: Version): Version {
  message[custom] = VersionCustomInspect;
  message[customJson] = VersionCustomJson;
  return message;
}

function createBaseVersion(): Version {
  const message: Version = {
    $type: "google.protobuf.compiler.Version",
    major: undefined,
    minor: undefined,
    patch: undefined,
    suffix: undefined,
  };
  return applyVersionCustom(message);
}

/**
 *  An encoded CodeGeneratorRequest is written to the plugin's stdin.
 *
 */
export interface CodeGeneratorRequest {
  $type: "google.protobuf.compiler.CodeGeneratorRequest";
  [unknownFieldsSymbol]?: Uint8Array | undefined;
  [custom]?: () => string;
  [customJson]?: () => unknown;
  /**
   *  The .proto files that were explicitly listed on the command-line.  The
   *  code generator should generate code only for these files.  Each file's
   *  descriptor will be included in proto_file, below.
   *
   */
  fileToGenerate: string[];
  /**
   *  The generator parameter passed on the command-line.
   *
   */
  parameter?: string | undefined;
  /**
   *  FileDescriptorProtos for all files in files_to_generate and everything
   *  they import.  The files will appear in topological order, so each file
   *  appears before any file that imports it.
   *
   *  Note: the files listed in files_to_generate will include runtime-retention
   *  options only, but all other files will include source-retention options.
   *  The source_file_descriptors field below is available in case you need
   *  source-retention options for files_to_generate.
   *
   *  protoc guarantees that all proto_files will be written after
   *  the fields above, even though this is not technically guaranteed by the
   *  protobuf wire format.  This theoretically could allow a plugin to stream
   *  in the FileDescriptorProtos and handle them one by one rather than read
   *  the entire set into memory at once.  However, as of this writing, this
   *  is not similarly optimized on protoc's end -- it will store all fields in
   *  memory at once before sending them to the plugin.
   *
   *  Type names of fields and extensions in the FileDescriptorProto are always
   *  fully qualified.
   *
   */
  protoFile: FileDescriptorProto[];
  /**
   *  File descriptors with all options, including source-retention options.
   *  These descriptors are only provided for the files listed in
   *  files_to_generate.
   *
   */
  sourceFileDescriptors: FileDescriptorProto[];
  /**
   *  The version number of protocol compiler.
   *
   */
  compilerVersion?: Version | undefined;
}

export const CodeGeneratorRequest: MessageFns<CodeGeneratorRequest, "google.protobuf.compiler.CodeGeneratorRequest"> = {
  $type: "google.protobuf.compiler.CodeGeneratorRequest" as const,

  encode(message: CodeGeneratorRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of (message.fileToGenerate ?? [])) {
      writer.uint32(10).string(v);
    }
    if (message.parameter !== undefined) {
      writer.uint32(18).string(message.parameter);
    }
    for (const v of (message.protoFile ?? [])) {
      const w = writer.uint32(122).fork();
      FileDescriptorProto.encode(v, w);
      w.join();
    }
    for (const v of (message.sourceFileDescriptors ?? [])) {
      const w = writer.uint32(138).fork();
      FileDescriptorProto.encode(v, w);
      w.join();
    }
    if (message.compilerVersion !== undefined) {
      const w = writer.uint32(26).fork();
      Version.encode(message.compilerVersion, w);
      w.join();
    }
    if (message[unknownFieldsSymbol]) {
      writer.raw(message[unknownFieldsSymbol]);
    }
    return writer;
  },
  decode(input: BinaryReader | Uint8Array, length?: number): CodeGeneratorRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCodeGeneratorRequest();
    let writer: BinaryWriter | undefined = undefined;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) break;
          message.fileToGenerate.push(reader.string());
          continue;
        }
        case 2: {
        if (tag !== 18) break;
        message.parameter = reader.string();
        continue;
      }
        case 15: {
          if (tag !== 122) break;
          message.protoFile.push(FileDescriptorProto.decode(reader, reader.uint32()));
          continue;
        }
        case 17: {
          if (tag !== 138) break;
          message.sourceFileDescriptors.push(FileDescriptorProto.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) break;
          message.compilerVersion = Version.decode(reader, reader.uint32());
          continue;
        }
        default:
          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      {
        if (!writer) writer = new BinaryWriter();
        const skipped = reader.skip(tag & 7, tag >>> 3);
        writer.uint32(tag).raw(skipped);
      }
    }
    if (writer) {
      message[unknownFieldsSymbol] = writer.finish();
    }
    return message;
  },
  fromJSON(object: any): CodeGeneratorRequest {
    return applyCodeGeneratorRequestCustom({
      $type: "google.protobuf.compiler.CodeGeneratorRequest",
      fileToGenerate: globalThis.Array.isArray(object?.fileToGenerate ?? object?.file_to_generate)
        ? (object.fileToGenerate ?? object.file_to_generate).map((e: any) => String(e))
        : [],
      parameter: isSet(object.parameter ?? object.parameter)
        ? String(object.parameter ?? object.parameter)
        : undefined,
      protoFile: globalThis.Array.isArray(object?.protoFile ?? object?.proto_file)
        ? (object.protoFile ?? object.proto_file).map((e: any) => FileDescriptorProto.fromJSON(e))
        : [],
      sourceFileDescriptors: globalThis.Array.isArray(object?.sourceFileDescriptors ?? object?.source_file_descriptors)
        ? (object.sourceFileDescriptors ?? object.source_file_descriptors).map((e: any) => FileDescriptorProto.fromJSON(e))
        : [],
      compilerVersion: isSet(object.compilerVersion ?? object.compiler_version)
        ? Version.fromJSON(object.compilerVersion ?? object.compiler_version)
        : undefined,
    });
  },
  toJSON(message: CodeGeneratorRequest, use: "json" | "pb" = "json"): unknown {
    const obj: any = {};
    const pick = (json: string, pb: string) => (use === "json" ? json : pb);
    if (message.fileToGenerate?.length) {
      obj[pick("fileToGenerate", "file_to_generate")] = message.fileToGenerate.map((e) => e);
    }
    if (message.parameter !== undefined) {
      obj[pick("parameter", "parameter")] = message.parameter;
    }
    if (message.protoFile?.length) {
      obj[pick("protoFile", "proto_file")] = message.protoFile.map((e) => e ? FileDescriptorProto.toJSON(e, use) : undefined);
    }
    if (message.sourceFileDescriptors?.length) {
      obj[pick("sourceFileDescriptors", "source_file_descriptors")] = message.sourceFileDescriptors.map((e) => e ? FileDescriptorProto.toJSON(e, use) : undefined);
    }
    if (message.compilerVersion !== undefined) {
      obj[pick("compilerVersion", "compiler_version")] = message.compilerVersion
        ? Version.toJSON(message.compilerVersion, use)
        : undefined;
    }
    return obj;
  },
  create<I extends DeepPartial<CodeGeneratorRequest>>(base?: I): CodeGeneratorRequest {
    return CodeGeneratorRequest.fromPartial(base ?? {});
  },
  fromPartial<I extends DeepPartial<CodeGeneratorRequest>>(object: I): CodeGeneratorRequest {
    const message = createBaseCodeGeneratorRequest();
    message.fileToGenerate = object.fileToGenerate?.map((e) => e) || [];
    message.parameter = (object.parameter !== undefined && object.parameter !== null)
      ? object.parameter
      : undefined;
    message.protoFile = object.protoFile?.map((e) => FileDescriptorProto.fromPartial(e)) || [];
    message.sourceFileDescriptors = object.sourceFileDescriptors?.map((e) => FileDescriptorProto.fromPartial(e)) || [];
    message.compilerVersion = (object.compilerVersion !== undefined && object.compilerVersion !== null)
      ? Version.fromPartial(object.compilerVersion)
      : undefined;
    return message;
  },
};

protoRegistry.registerMessage(CodeGeneratorRequest);

function CodeGeneratorRequestCustomInspect(this: CodeGeneratorRequest): string {
  const parts: string[] = [];
  if ((this.fileToGenerate?.length ?? 0) !== 0) parts.push("fileToGenerate" + "=" + inspect(this.fileToGenerate));
  if (this.parameter !== undefined) parts.push("parameter" + "=" + inspect(this.parameter));
  if ((this.protoFile?.length ?? 0) !== 0) parts.push("protoFile" + "=" + inspect(this.protoFile));
  if ((this.sourceFileDescriptors?.length ?? 0) !== 0) parts.push("sourceFileDescriptors" + "=" + inspect(this.sourceFileDescriptors));
  if (this.compilerVersion !== undefined) parts.push("compilerVersion" + "=" + inspect(this.compilerVersion));
  return `${this.$type}(${parts.join(", ")})`;
}

function CodeGeneratorRequestCustomJson(this: CodeGeneratorRequest): unknown {
  const obj: globalThis.Record<string, unknown> = {
    type: this.$type,
  };
  if ((this.fileToGenerate?.length ?? 0) !== 0) obj.fileToGenerate = inspectJson(this.fileToGenerate);
  if (this.parameter !== undefined) obj.parameter = inspectJson(this.parameter);
  if ((this.protoFile?.length ?? 0) !== 0) obj.protoFile = inspectJson(this.protoFile);
  if ((this.sourceFileDescriptors?.length ?? 0) !== 0) obj.sourceFileDescriptors = inspectJson(this.sourceFileDescriptors);
  if (this.compilerVersion !== undefined) obj.compilerVersion = inspectJson(this.compilerVersion);
  return obj;
}

function applyCodeGeneratorRequestCustom(message: CodeGeneratorRequest): CodeGeneratorRequest {
  message[custom] = CodeGeneratorRequestCustomInspect;
  message[customJson] = CodeGeneratorRequestCustomJson;
  return message;
}

function createBaseCodeGeneratorRequest(): CodeGeneratorRequest {
  const message: CodeGeneratorRequest = {
    $type: "google.protobuf.compiler.CodeGeneratorRequest",
    fileToGenerate: [],
    parameter: undefined,
    protoFile: [],
    sourceFileDescriptors: [],
    compilerVersion: undefined,
  };
  return applyCodeGeneratorRequestCustom(message);
}

/**
 *  The plugin writes an encoded CodeGeneratorResponse to stdout.
 *
 */
export interface CodeGeneratorResponse {
  $type: "google.protobuf.compiler.CodeGeneratorResponse";
  [unknownFieldsSymbol]?: Uint8Array | undefined;
  [custom]?: () => string;
  [customJson]?: () => unknown;
  /**
   *  Error message.  If non-empty, code generation failed.  The plugin process
   *  should exit with status code zero even if it reports an error in this way.
   *
   *  This should be used to indicate errors in .proto files which prevent the
   *  code generator from generating correct code.  Errors which indicate a
   *  problem in protoc itself -- such as the input CodeGeneratorRequest being
   *  unparseable -- should be reported by writing a message to stderr and
   *  exiting with a non-zero status code.
   *
   */
  error?: string | undefined;
  /**
   *  A bitmask of supported features that the code generator supports.
   *  This is a bitwise "or" of values from the Feature enum.
   *
   */
  supportedFeatures?: Long | undefined;
  /**
   *  The minimum edition this plugin supports.  This will be treated as an
   *  Edition enum, but we want to allow unknown values.  It should be specified
   *  according the edition enum value, *not* the edition number.  Only takes
   *  effect for plugins that have FEATURE_SUPPORTS_EDITIONS set.
   *
   */
  minimumEdition?: number | undefined;
  /**
   *  The maximum edition this plugin supports.  This will be treated as an
   *  Edition enum, but we want to allow unknown values.  It should be specified
   *  according the edition enum value, *not* the edition number.  Only takes
   *  effect for plugins that have FEATURE_SUPPORTS_EDITIONS set.
   *
   */
  maximumEdition?: number | undefined;
  file: CodeGeneratorResponse_File[];
}

export const CodeGeneratorResponse: MessageFns<CodeGeneratorResponse, "google.protobuf.compiler.CodeGeneratorResponse"> = {
  $type: "google.protobuf.compiler.CodeGeneratorResponse" as const,

  encode(message: CodeGeneratorResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.error !== undefined) {
      writer.uint32(10).string(message.error);
    }
    if (message.supportedFeatures !== undefined) {
      writer.uint32(16).uint64(message.supportedFeatures.toString());
    }
    if (message.minimumEdition !== undefined) {
      writer.uint32(24).int32(message.minimumEdition);
    }
    if (message.maximumEdition !== undefined) {
      writer.uint32(32).int32(message.maximumEdition);
    }
    for (const v of (message.file ?? [])) {
      const w = writer.uint32(122).fork();
      CodeGeneratorResponse_File.encode(v, w);
      w.join();
    }
    if (message[unknownFieldsSymbol]) {
      writer.raw(message[unknownFieldsSymbol]);
    }
    return writer;
  },
  decode(input: BinaryReader | Uint8Array, length?: number): CodeGeneratorResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCodeGeneratorResponse();
    let writer: BinaryWriter | undefined = undefined;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
        if (tag !== 10) break;
        message.error = reader.string();
        continue;
      }
        case 2: {
        if (tag !== 16) break;
        message.supportedFeatures = Long.fromValue(reader.uint64());
        continue;
      }
        case 3: {
        if (tag !== 24) break;
        message.minimumEdition = reader.int32();
        continue;
      }
        case 4: {
        if (tag !== 32) break;
        message.maximumEdition = reader.int32();
        continue;
      }
        case 15: {
          if (tag !== 122) break;
          message.file.push(CodeGeneratorResponse_File.decode(reader, reader.uint32()));
          continue;
        }
        default:
          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      {
        if (!writer) writer = new BinaryWriter();
        const skipped = reader.skip(tag & 7, tag >>> 3);
        writer.uint32(tag).raw(skipped);
      }
    }
    if (writer) {
      message[unknownFieldsSymbol] = writer.finish();
    }
    return message;
  },
  fromJSON(object: any): CodeGeneratorResponse {
    return applyCodeGeneratorResponseCustom({
      $type: "google.protobuf.compiler.CodeGeneratorResponse",
      error: isSet(object.error ?? object.error)
        ? String(object.error ?? object.error)
        : undefined,
      supportedFeatures: isSet(object.supportedFeatures ?? object.supported_features)
        ? Long.fromValue(object.supportedFeatures ?? object.supported_features)
        : undefined,
      minimumEdition: isSet(object.minimumEdition ?? object.minimum_edition)
        ? Number(object.minimumEdition ?? object.minimum_edition)
        : undefined,
      maximumEdition: isSet(object.maximumEdition ?? object.maximum_edition)
        ? Number(object.maximumEdition ?? object.maximum_edition)
        : undefined,
      file: globalThis.Array.isArray(object?.file ?? object?.file)
        ? (object.file ?? object.file).map((e: any) => CodeGeneratorResponse_File.fromJSON(e))
        : [],
    });
  },
  toJSON(message: CodeGeneratorResponse, use: "json" | "pb" = "json"): unknown {
    const obj: any = {};
    const pick = (json: string, pb: string) => (use === "json" ? json : pb);
    if (message.error !== undefined) {
      obj[pick("error", "error")] = message.error;
    }
    if (message.supportedFeatures !== undefined) {
      obj[pick("supportedFeatures", "supported_features")] = (message.supportedFeatures || Long.ZERO).toString();
    }
    if (message.minimumEdition !== undefined) {
      obj[pick("minimumEdition", "minimum_edition")] = message.minimumEdition;
    }
    if (message.maximumEdition !== undefined) {
      obj[pick("maximumEdition", "maximum_edition")] = message.maximumEdition;
    }
    if (message.file?.length) {
      obj[pick("file", "file")] = message.file.map((e) => e ? CodeGeneratorResponse_File.toJSON(e, use) : undefined);
    }
    return obj;
  },
  create<I extends DeepPartial<CodeGeneratorResponse>>(base?: I): CodeGeneratorResponse {
    return CodeGeneratorResponse.fromPartial(base ?? {});
  },
  fromPartial<I extends DeepPartial<CodeGeneratorResponse>>(object: I): CodeGeneratorResponse {
    const message = createBaseCodeGeneratorResponse();
    message.error = (object.error !== undefined && object.error !== null)
      ? object.error
      : undefined;
    message.supportedFeatures = (object.supportedFeatures !== undefined && object.supportedFeatures !== null)
      ? Long.fromValue(object.supportedFeatures)
      : undefined;
    message.minimumEdition = (object.minimumEdition !== undefined && object.minimumEdition !== null)
      ? object.minimumEdition
      : undefined;
    message.maximumEdition = (object.maximumEdition !== undefined && object.maximumEdition !== null)
      ? object.maximumEdition
      : undefined;
    message.file = object.file?.map((e) => CodeGeneratorResponse_File.fromPartial(e)) || [];
    return message;
  },
};

protoRegistry.registerMessage(CodeGeneratorResponse);

function CodeGeneratorResponseCustomInspect(this: CodeGeneratorResponse): string {
  const parts: string[] = [];
  if (this.error !== undefined) parts.push("error" + "=" + inspect(this.error));
  if (this.supportedFeatures !== undefined) parts.push("supportedFeatures" + "=" + inspect(this.supportedFeatures));
  if (this.minimumEdition !== undefined) parts.push("minimumEdition" + "=" + inspect(this.minimumEdition));
  if (this.maximumEdition !== undefined) parts.push("maximumEdition" + "=" + inspect(this.maximumEdition));
  if ((this.file?.length ?? 0) !== 0) parts.push("file" + "=" + inspect(this.file));
  return `${this.$type}(${parts.join(", ")})`;
}

function CodeGeneratorResponseCustomJson(this: CodeGeneratorResponse): unknown {
  const obj: globalThis.Record<string, unknown> = {
    type: this.$type,
  };
  if (this.error !== undefined) obj.error = inspectJson(this.error);
  if (this.supportedFeatures !== undefined) obj.supportedFeatures = inspectJson(this.supportedFeatures);
  if (this.minimumEdition !== undefined) obj.minimumEdition = inspectJson(this.minimumEdition);
  if (this.maximumEdition !== undefined) obj.maximumEdition = inspectJson(this.maximumEdition);
  if ((this.file?.length ?? 0) !== 0) obj.file = inspectJson(this.file);
  return obj;
}

function applyCodeGeneratorResponseCustom(message: CodeGeneratorResponse): CodeGeneratorResponse {
  message[custom] = CodeGeneratorResponseCustomInspect;
  message[customJson] = CodeGeneratorResponseCustomJson;
  return message;
}

function createBaseCodeGeneratorResponse(): CodeGeneratorResponse {
  const message: CodeGeneratorResponse = {
    $type: "google.protobuf.compiler.CodeGeneratorResponse",
    error: undefined,
    supportedFeatures: undefined,
    minimumEdition: undefined,
    maximumEdition: undefined,
    file: [],
  };
  return applyCodeGeneratorResponseCustom(message);
}

/**
 *  Represents a single generated file.
 *
 */
export interface CodeGeneratorResponse_File {
  $type: "google.protobuf.compiler.CodeGeneratorResponse.File";
  [unknownFieldsSymbol]?: Uint8Array | undefined;
  [custom]?: () => string;
  [customJson]?: () => unknown;
  /**
   *  The file name, relative to the output directory.  The name must not
   *  contain "." or ".." components and must be relative, not be absolute (so,
   *  the file cannot lie outside the output directory).  "/" must be used as
   *  the path separator, not "\".
   *
   *  If the name is omitted, the content will be appended to the previous
   *  file.  This allows the generator to break large files into small chunks,
   *  and allows the generated text to be streamed back to protoc so that large
   *  files need not reside completely in memory at one time.  Note that as of
   *  this writing protoc does not optimize for this -- it will read the entire
   *  CodeGeneratorResponse before writing files to disk.
   *
   */
  name?: string | undefined;
  /**
   *  If non-empty, indicates that the named file should already exist, and the
   *  content here is to be inserted into that file at a defined insertion
   *  point.  This feature allows a code generator to extend the output
   *  produced by another code generator.  The original generator may provide
   *  insertion points by placing special annotations in the file that look
   *  like:
   *    @@protoc_insertion_point(NAME)
   *  The annotation can have arbitrary text before and after it on the line,
   *  which allows it to be placed in a comment.  NAME should be replaced with
   *  an identifier naming the point -- this is what other generators will use
   *  as the insertion_point.  Code inserted at this point will be placed
   *  immediately above the line containing the insertion point (thus multiple
   *  insertions to the same point will come out in the order they were added).
   *  The double-@ is intended to make it unlikely that the generated code
   *  could contain things that look like insertion points by accident.
   *
   *  For example, the C++ code generator places the following line in the
   *  .pb.h files that it generates:
   *    // @@protoc_insertion_point(namespace_scope)
   *  This line appears within the scope of the file's package namespace, but
   *  outside of any particular class.  Another plugin can then specify the
   *  insertion_point "namespace_scope" to generate additional classes or
   *  other declarations that should be placed in this scope.
   *
   *  Note that if the line containing the insertion point begins with
   *  whitespace, the same whitespace will be added to every line of the
   *  inserted text.  This is useful for languages like Python, where
   *  indentation matters.  In these languages, the insertion point comment
   *  should be indented the same amount as any inserted code will need to be
   *  in order to work correctly in that context.
   *
   *  The code generator that generates the initial file and the one which
   *  inserts into it must both run as part of a single invocation of protoc.
   *  Code generators are executed in the order in which they appear on the
   *  command line.
   *
   *  If |insertion_point| is present, |name| must also be present.
   *
   */
  insertionPoint?: string | undefined;
  /**
   *  The file contents.
   *
   */
  content?: string | undefined;
  /**
   *  Information describing the file content being inserted. If an insertion
   *  point is used, this information will be appropriately offset and inserted
   *  into the code generation metadata for the generated files.
   *
   */
  generatedCodeInfo?: GeneratedCodeInfo | undefined;
}

export const CodeGeneratorResponse_File: MessageFns<CodeGeneratorResponse_File, "google.protobuf.compiler.CodeGeneratorResponse.File"> = {
  $type: "google.protobuf.compiler.CodeGeneratorResponse.File" as const,

  encode(message: CodeGeneratorResponse_File, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== undefined) {
      writer.uint32(10).string(message.name);
    }
    if (message.insertionPoint !== undefined) {
      writer.uint32(18).string(message.insertionPoint);
    }
    if (message.content !== undefined) {
      writer.uint32(122).string(message.content);
    }
    if (message.generatedCodeInfo !== undefined) {
      const w = writer.uint32(130).fork();
      GeneratedCodeInfo.encode(message.generatedCodeInfo, w);
      w.join();
    }
    if (message[unknownFieldsSymbol]) {
      writer.raw(message[unknownFieldsSymbol]);
    }
    return writer;
  },
  decode(input: BinaryReader | Uint8Array, length?: number): CodeGeneratorResponse_File {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCodeGeneratorResponse_File();
    let writer: BinaryWriter | undefined = undefined;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
        if (tag !== 10) break;
        message.name = reader.string();
        continue;
      }
        case 2: {
        if (tag !== 18) break;
        message.insertionPoint = reader.string();
        continue;
      }
        case 15: {
        if (tag !== 122) break;
        message.content = reader.string();
        continue;
      }
        case 16: {
          if (tag !== 130) break;
          message.generatedCodeInfo = GeneratedCodeInfo.decode(reader, reader.uint32());
          continue;
        }
        default:
          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      {
        if (!writer) writer = new BinaryWriter();
        const skipped = reader.skip(tag & 7, tag >>> 3);
        writer.uint32(tag).raw(skipped);
      }
    }
    if (writer) {
      message[unknownFieldsSymbol] = writer.finish();
    }
    return message;
  },
  fromJSON(object: any): CodeGeneratorResponse_File {
    return applyCodeGeneratorResponse_FileCustom({
      $type: "google.protobuf.compiler.CodeGeneratorResponse.File",
      name: isSet(object.name ?? object.name)
        ? String(object.name ?? object.name)
        : undefined,
      insertionPoint: isSet(object.insertionPoint ?? object.insertion_point)
        ? String(object.insertionPoint ?? object.insertion_point)
        : undefined,
      content: isSet(object.content ?? object.content)
        ? String(object.content ?? object.content)
        : undefined,
      generatedCodeInfo: isSet(object.generatedCodeInfo ?? object.generated_code_info)
        ? GeneratedCodeInfo.fromJSON(object.generatedCodeInfo ?? object.generated_code_info)
        : undefined,
    });
  },
  toJSON(message: CodeGeneratorResponse_File, use: "json" | "pb" = "json"): unknown {
    const obj: any = {};
    const pick = (json: string, pb: string) => (use === "json" ? json : pb);
    if (message.name !== undefined) {
      obj[pick("name", "name")] = message.name;
    }
    if (message.insertionPoint !== undefined) {
      obj[pick("insertionPoint", "insertion_point")] = message.insertionPoint;
    }
    if (message.content !== undefined) {
      obj[pick("content", "content")] = message.content;
    }
    if (message.generatedCodeInfo !== undefined) {
      obj[pick("generatedCodeInfo", "generated_code_info")] = message.generatedCodeInfo
        ? GeneratedCodeInfo.toJSON(message.generatedCodeInfo, use)
        : undefined;
    }
    return obj;
  },
  create<I extends DeepPartial<CodeGeneratorResponse_File>>(base?: I): CodeGeneratorResponse_File {
    return CodeGeneratorResponse_File.fromPartial(base ?? {});
  },
  fromPartial<I extends DeepPartial<CodeGeneratorResponse_File>>(object: I): CodeGeneratorResponse_File {
    const message = createBaseCodeGeneratorResponse_File();
    message.name = (object.name !== undefined && object.name !== null)
      ? object.name
      : undefined;
    message.insertionPoint = (object.insertionPoint !== undefined && object.insertionPoint !== null)
      ? object.insertionPoint
      : undefined;
    message.content = (object.content !== undefined && object.content !== null)
      ? object.content
      : undefined;
    message.generatedCodeInfo = (object.generatedCodeInfo !== undefined && object.generatedCodeInfo !== null)
      ? GeneratedCodeInfo.fromPartial(object.generatedCodeInfo)
      : undefined;
    return message;
  },
};

protoRegistry.registerMessage(CodeGeneratorResponse_File);

function CodeGeneratorResponse_FileCustomInspect(this: CodeGeneratorResponse_File): string {
  const parts: string[] = [];
  if (this.name !== undefined) parts.push("name" + "=" + inspect(this.name));
  if (this.insertionPoint !== undefined) parts.push("insertionPoint" + "=" + inspect(this.insertionPoint));
  if (this.content !== undefined) parts.push("content" + "=" + inspect(this.content));
  if (this.generatedCodeInfo !== undefined) parts.push("generatedCodeInfo" + "=" + inspect(this.generatedCodeInfo));
  return `${this.$type}(${parts.join(", ")})`;
}

function CodeGeneratorResponse_FileCustomJson(this: CodeGeneratorResponse_File): unknown {
  const obj: globalThis.Record<string, unknown> = {
    type: this.$type,
  };
  if (this.name !== undefined) obj.name = inspectJson(this.name);
  if (this.insertionPoint !== undefined) obj.insertionPoint = inspectJson(this.insertionPoint);
  if (this.content !== undefined) obj.content = inspectJson(this.content);
  if (this.generatedCodeInfo !== undefined) obj.generatedCodeInfo = inspectJson(this.generatedCodeInfo);
  return obj;
}

function applyCodeGeneratorResponse_FileCustom(message: CodeGeneratorResponse_File): CodeGeneratorResponse_File {
  message[custom] = CodeGeneratorResponse_FileCustomInspect;
  message[customJson] = CodeGeneratorResponse_FileCustomJson;
  return message;
}

function createBaseCodeGeneratorResponse_File(): CodeGeneratorResponse_File {
  const message: CodeGeneratorResponse_File = {
    $type: "google.protobuf.compiler.CodeGeneratorResponse.File",
    name: undefined,
    insertionPoint: undefined,
    content: undefined,
    generatedCodeInfo: undefined,
  };
  return applyCodeGeneratorResponse_FileCustom(message);
}

